<!DOCTYPE html>
<html lang="ja">
  <link rel="icon" href="https://avatars.githubusercontent.com/u/120705481?s=48&v=4" type="image/x-icon">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>基本情報基礎技術者試験の四択問題</title>
  <link rel="stylesheet" href="../../keep_out/selectQuestion.css">
  <style>
    .options label.disabled {
      pointer-events: none;
      color: #000;
    }
  </style>
  <audio id="se-correct" src="../../keep_out/correct.mp3" preload="auto"></audio>
  <audio id="se-wrong" src="../../keep_out/wrong.mp3" preload="auto"></audio>
  <audio id="se-start" src="../../keep_out/start.mp3" preload="auto"></audio>
  <audio id="se-end" src="../../keep_out/end.mp3" preload="auto"></audio>
</head>
<body>
  <audio id="bgm" src="../../keep_out/BGM.mp3" loop></audio>
  <button id="bgm-toggle">▶️ BGMを再生</button>
  <div class="quiz-container" id="home">
    <h1>基本情報基礎技術者試験の四択問題</h1>
    <p>全10問です</p>
    <button onclick="startQuiz()">開始</button>
    <a href="FITEE.html" class="back-button">問題選択に戻る</a>
  </div>

  <div class="quiz-container" id="quiz" style="display: none;"></div>
  <div id="countdown-overlay" class="countdown-overlay">
  <div id="countdown-text" class="countdown-text"></div>
  </div>
  <script>
    const RANKING_KEY = "FITEE";
    let questions = [

{
  q: "次のうち、ソフトウェア開発におけるウォーターフォールモデルの特徴として正しいものはどれか",
  options: [
    "開発プロセスが反復的である。",
    "各工程が明確に分離されている。",
    "顧客とのコミュニケーションを重視する。",
    "テスト工程が開発の初期段階で行われる。"
  ],
  answer: 1,
  explanation: "ウォーターフォールモデルは、各工程が明確に分離され、順番に進む開発手法である。<br>他の選択肢はアジャイル開発などの特徴である。"
},
{
  q: "次のうち、ソフトウェア開発におけるアジャイル開発の特徴として正しいものはどれか",
  options: [
    "ウォーターフォールモデルに基づいて開発を行う。",
    "顧客とのコミュニケーションを重視し、短期間で反復的に開発を行う。",
    "ドキュメントを重視し、詳細な仕様書を作成する。",
    "開発チームが独立して作業を進めることが求められる。"
  ],
  answer: 1,
  explanation: "アジャイル開発は、顧客とのコミュニケーションと短期間での反復的な開発を重視する手法である。<br>他の選択肢はアジャイル開発の特徴ではない。"
},
{
  q: "次のうち、ソフトウェア開発におけるバージョン管理システムの目的として正しいものはどれか",
  options: [
    "ソフトウェアの実行速度を向上させる。",
    "ソフトウェアのコードを暗号化する。",
    "ソフトウェアの変更履歴を管理する。",
    "ソフトウェアのユーザーインターフェースを改善する。"
  ],
  answer: 2,
  explanation: "バージョン管理システムは、ソフトウェアの変更履歴を管理し、複数人での共同開発を容易にするために使用される。<br>他の選択肢はバージョン管理システムの目的ではない。"
},
{
  q: "次のうち、ソフトウェア開発におけるリファクタリングの目的として正しいものはどれか",
  options: [
    "ソフトウェアの機能を追加するために使用される。",
    "ソフトウェアのコードを最適化し、可読性を向上させるために使用される。",
    "ソフトウェアのバグを修正するために使用される。",
    "ソフトウェアのパフォーマンスを向上させるために使用される。"
  ],
  answer: 1,
  explanation: "リファクタリングは、ソフトウェアのコードを最適化し、可読性や保守性を向上させるために行われる。<br>他の選択肢はリファクタリングの目的ではない。"
},
{
  q: "次のうち、ソフトウェア開発におけるユニットテストの目的として正しいものはどれか",
  options: [
    "ソフトウェアの機能を追加するために使用される。",
    "ソフトウェアのコードを他の開発者と共有し、品質を向上させるために使用される。",
    "ソフトウェアの個々の部品（ユニット）を検証し、バグを早期に発見するために使用される。",
    "ソフトウェアのパフォーマンスを測定するために使用される。"
  ],
  answer: 2,
  explanation: "ユニットテストは、ソフトウェアの個々の部品（ユニット）を検証し、バグを早期に発見するために行われる。<br>他の選択肢はユニットテストの目的ではない。"
},
{
  q: "次のうち、ソフトウェア開発におけるテストの目的として正しいものはどれか",
  options: [
    "ソフトウェアの機能を追加する。",
    "ソフトウェアのバグを修正する。",
    "ソフトウェアが仕様通りに動作することを確認する。",
    "ソフトウェアのパフォーマンスを向上させる。"
  ],
  answer: 2,
  explanation: "テストは、ソフトウェアが仕様通りに動作することを確認し、品質を保証するために行われる。<br>他の選択肢はテストの目的ではない。"
},
{
  q: "次のうち、ソフトウェア開発におけるコードレビューの目的として正しいものはどれか",
  options: [
    "ソフトウェアの機能を追加するために使用される。",
    "ソフトウェアのコードを他の開発者と共有し、品質を向上させるために使用される。",
    "ソフトウェアのバグを自動的に修正するために使用される。",
    "ソフトウェアのパフォーマンスを測定するために使用される。"
  ],
  answer: 1,
  explanation: "コードレビューは、他の開発者とコードを共有し、品質や可読性を向上させるために行われる。<br>他の選択肢はコードレビューの目的ではない。"
},

// 💻 2. プログラミング（構文・アルゴリズム）
{
  q: "次のPythonコードを実行したときの出力として正しいものはどれか。\n\nprint(sum([i for i in range(1, 6)]))",
  options: [
    "10",
    "15",
    "20",
    "21"
  ],
  answer: 1,
  explanation: "リスト [1, 2, 3, 4, 5] の合計は 15 である。sum関数はその合計値を返す。"
},
{
  q: "次のアルゴリズムの説明として正しいものはどれか。\n\n「線形探索は、探索対象のリストを先頭から順番に調べていき、目的の値を見つけるまで続けるアルゴリズムである。」",
  options: [
    "探索対象のリストが整列されている必要がある。",
    "高速な探索を実現するためにヒープ構造を利用する。",
    "探索対象のリストの順序に関係なく使用できる。",
    "探索対象のリストが二分木である必要がある。"
  ],
  answer: 2,
  explanation: "線形探索は、整列や構造に関係なく使える探索方法であり、順に要素を調べる単純な手法である。"
},

// 🧪 3. テスト・品質保証
{
  q: "ソフトウェアテストにおけるブラックボックステストの説明として正しいものはどれか。",
  options: [
    "ソースコードを参照して内部構造を確認しながら行う。",
    "外部仕様に基づいて入力と出力のみを検証する。",
    "すべての分岐とパスを網羅することを目的とする。",
    "ソフトウェアの開発者によって実施される。"
  ],
  answer: 1,
  explanation: "ブラックボックステストは、外部仕様に基づいて行うもので、内部構造を考慮しない。<br>コードを見ないでテストする方式である。"
},

// 🧠 4. アルゴリズムとデータ構造
{
  q: "次のうち、探索に二分探索法が適用できる条件として正しいものはどれか。",
  options: [
    "データがランダムに並んでいる必要がある。",
    "データがあらかじめ整列（ソート）されている必要がある。",
    "データがリンクリストで管理されている必要がある。",
    "データがツリー構造で表現されている必要がある。"
  ],
  answer: 1,
  explanation: "二分探索法は、探索対象が整列（ソート）されている必要がある。<br>整列されていないと正しく動作しない。"
},

// 🖥️ 5. コンピュータ構成・アーキテクチャ
{
  q: "次のうち、キャッシュメモリの役割として最も適切なものはどれか。",
  options: [
    "CPUの計算速度を落とす。",
    "主記憶の容量を増やす。",
    "CPUと主記憶の間のアクセス速度の差を埋める。",
    "プログラムのバグを自動的に修正する。"
  ],
  answer: 2,
  explanation: "キャッシュメモリは、CPUと主記憶の間の速度差を補うために使用される高速なメモリである。"
},

// 🧩 6. OS・プロセス管理
{
  q: "オペレーティングシステムにおける仮想記憶の説明として正しいものはどれか。",
  options: [
    "実際の記憶容量を増やす。",
    "記憶装置の寿命を延ばす。",
    "主記憶に収まらないプログラムを実行できるようにする。",
    "OSを高速化するために利用される。"
  ],
  answer: 2,
  explanation: "仮想記憶は、主記憶の容量を超えるプログラムを実行可能にする仕組みである。<br>主記憶の一部をディスクで補う。"
},

// 🌐 7. ネットワーク・セキュリティ
{
  q: "次のうち、パケットフィルタリング型ファイアウォールの特徴として正しいものはどれか。",
  options: [
    "アプリケーション層での内容を確認して通信を制御する。",
    "IPアドレスやポート番号などに基づいて通信を制御する。",
    "ユーザ認証を行うことができる。",
    "暗号化通信の内容を復号して確認できる。"
  ],
  answer: 1,
  explanation: "パケットフィルタリング型ファイアウォールは、IPアドレスやポート番号などの情報に基づいて通信を制御する。"
},
{
  q: "次のうち、HTTPS通信の特徴として正しいものはどれか。",
  options: [
    "通信内容が平文で送信される。",
    "通信相手の正当性が確認されない。",
    "通信内容が暗号化されて送信される。",
    "通信にはUDPを使用する。"
  ],
  answer: 2,
  explanation: "HTTPSは、SSL/TLSを用いて通信内容を暗号化し、安全な通信を実現するプロトコルである。"
}

    ];

    function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}


    function escapeHTMLExceptBR(str) {
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/&lt;br&gt;/g, "<br>")
    .replace(/&lt;pre&gt;/g, "<pre>")
    .replace(/&lt;\/pre&gt;/g, "</pre>");
}

    let current = 0;
    let score = 0;
    let backClickCount = 0;

const backButtonHome = document.querySelector(".back-button");
if (backButtonHome) {
  backButtonHome.addEventListener("click", function(e) {
    e.preventDefault();
    if (backClickCount === 0) {
      alert("本当に戻りますか？もう一度クリックすると戻ります。");
      backClickCount++;
    } else {
      window.location.href = "FITEE.html";
    }
  });
}

    const homeEl = document.getElementById("home");
    const quizEl = document.getElementById("quiz");

    function startQuiz() {
      const startButton = homeEl.querySelector("button");
      startButton.disabled = true;

      const seStart = document.getElementById('se-start');
      seStart.currentTime = 0;
      seStart.play();
      
      const countdownOverlay = document.getElementById('countdown-overlay');
      const countdownText = document.getElementById('countdown-text');
      
      countdownOverlay.style.display = 'flex';

      let count = 3;
      countdownText.textContent = count;

      const countdownTimer = setInterval(() => {
        count--;
        if (count > 0) {
          countdownText.textContent = count;
        } else {
          countdownText.textContent = 'START!';
        }
      }, 1000);

      setTimeout(() => {
        clearInterval(countdownTimer);
        countdownOverlay.style.display = 'none';

        if(bgmToggleBtn.textContent == "▶️ BGMを再生") {
          document.getElementById('bgm').play();
          bgmToggleBtn.textContent = '⏸️ BGMを停止';
        }
        shuffle(questions);
        questions = questions.slice(0, 10);
        current = 0;
        score = 0;
        homeEl.style.display = "none";
        quizEl.style.display = "block";
        showQuestion(current);
        startButton.disabled = false;
      }, 3500);
    }

    function showQuestion(index) {
      quizEl.innerHTML = "";
      const q = questions[index];

      const container = document.createElement("div");
      container.className = "question";

      const title = document.createElement("div");
      title.innerHTML = `<strong>Q${index + 1}:</strong> ${escapeHTMLExceptBR(q.q)}`;

      container.appendChild(title);

      const options = document.createElement("div");
      options.className = "options";

      q.options.forEach((opt, i) => {
        const label = document.createElement("label");
        const input = document.createElement("input");
        input.type = "radio";
        input.name = `q${index}`;
        input.value = i;
        label.appendChild(input);
        label.appendChild(document.createTextNode(" " + opt));
        options.appendChild(label);
      });

      container.appendChild(options);

      const button = document.createElement("button");
      button.textContent = "解答";

      const result = document.createElement("div");
      result.className = "result";

      const explanation = document.createElement("div");
      explanation.className = "explanation";

      const backButton = document.createElement("a");
      backButton.href = "FITEE.html";
      backButton.className = "home-button";
      backButton.textContent = "問題選択に戻る";

      backButton.addEventListener("click", function(e) {
        e.preventDefault();
        if (backClickCount === 0) {
          alert("本当に戻りますか？もう一度クリックすると戻ります。");
          backClickCount++;
        } else {
          window.location.href = "FITEE.html";
        }
      });

      const nextButton = document.createElement("button");
      nextButton.textContent = "次へ";
      nextButton.style.display = "none";
      nextButton.style.margin = "20px auto";
      
      nextButton.onclick = () => {
    setTimeout(() => {
    current++;
    backClickCount = 0;
    if (current < questions.length) {
      showQuestion(current);
    } else {
          const seEnd = document.getElementById('se-end');
          seEnd.currentTime = 0;
          seEnd.play();
          backClickCount = 1;
          quizEl.innerHTML = "";
          const container = document.createElement("div");
          quizEl.innerHTML = `<h2>お疲れ様でした！全${questions.length}問が終了しました。<br><br>${score}問正解しました！</h2>`;
          const today = new Date().toLocaleString();
          const newRecord = { date: today, score: score };

          let ranking = JSON.parse(localStorage.getItem(RANKING_KEY) || "[]");
          ranking.push(newRecord);

          ranking.sort((a, b) => b.score - a.score);
          ranking = ranking.slice(0, 5);

          localStorage.setItem(RANKING_KEY, JSON.stringify(ranking));

          const rankingList = document.createElement("div");
          rankingList.innerHTML = "<h3>🏆正解数ランキング(ローカル)</h3>";

          ranking.forEach((r, i) => {
            rankingList.innerHTML += `${i + 1}位: ${r.score}点（${r.date}）<br>`;
          });

          const retryBtn = document.createElement("button");
          retryBtn.textContent = "最初からやり直す";
          retryBtn.onclick = () => {
          startQuiz();
        };

          let resetClickCount = 0;

          const resetBtn = document.createElement("button");
          resetBtn.textContent = "ランキングをリセット";
          resetBtn.onclick = () => {
            if (resetClickCount === 0) {
              alert("本当にリセットしますか？もう一度クリックするとリセットされます。");
              resetClickCount++;
            } else {
              localStorage.removeItem(RANKING_KEY);
              location.reload();
            }
          };
      quizEl.appendChild(backButton);
      container.appendChild(retryBtn);
      container.appendChild(rankingList);
      container.appendChild(resetBtn);
      quizEl.appendChild(container);
    }
  }, 100);
};


      const nextButtonWrapper = document.createElement("div");
      nextButtonWrapper.style.textAlign = "center";
      nextButtonWrapper.appendChild(nextButton);

      button.onclick = () => {
        const selected = container.querySelector("input:checked");
        if (!selected) {
          result.textContent = "選択肢を選んでください。";
          result.style.color = "black";
          return;
        }

        const isCorrect = parseInt(selected.value) === q.answer;
        const seCorrect = document.getElementById("se-correct");
        const seWrong = document.getElementById("se-wrong");

        if (isCorrect) {
          result.classList.add("correct");
          score++;
          seCorrect.currentTime = 0;
          seCorrect.play();
        } else {
          result.classList.add("wrong");
          seWrong.currentTime = 0;
          seWrong.play();
        }
        
        result.textContent = isCorrect ? "○ 正解です！" : `× 不正解です。正解：${q.options[q.answer]}`;
        result.style.color = isCorrect ? "green" : "red";
        explanation.innerHTML = escapeHTMLExceptBR(q.explanation);

        const labels = container.querySelectorAll("label");
        labels.forEach(label => label.classList.add("disabled"));

        button.style.display = "none";
        nextButton.style.display = "inline-block";
      };

      container.appendChild(button);
      container.appendChild(result);
      container.appendChild(explanation);
      container.appendChild(nextButtonWrapper);
      container.appendChild(backButton);

      quizEl.appendChild(container);
    }

  const bgm = document.getElementById('bgm');
  const bgmToggleBtn = document.getElementById('bgm-toggle');

  bgmToggleBtn.addEventListener('click', () => {
    if (!bgm.paused) {
      bgm.pause();
      bgmToggleBtn.textContent = '▶️ BGMを再開';
    } else {
      bgm.play();
      bgmToggleBtn.textContent = '⏸️ BGMを停止';
  }
});
 
  </script>
</body>
</html>
